*** a/tools.py
--- b/tools.py
@@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Dict, List, Optional, Tuple
@@
-def _estimate_price_and_time_km(distance_km: float) -> Dict[str, Any]:
-    start_fee = TAXI_TARIFF.get("minimum_fare", 4.0)
-    per_km    = TAXI_TARIFF.get("km_rate_zone2_or_night", 1.25)  # Î³Î¹Î± intercity
-    avg_kmh   = 85.0
+def _estimate_price_and_time_km(distance_km: float, *, night: bool = False) -> Dict[str, Any]:
+    """
+    Î§Î¿Î½Î´ÏÎ¹ÎºÎ® ÎµÎºÏ„Î¯Î¼Î·ÏƒÎ· ÎºÏŒÏƒÏ„Î¿Ï…Ï‚/Ï‡ÏÏŒÎ½Î¿Ï… Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·Ï‚ (Ï‡Ï‰ÏÎ¯Ï‚ Î´Î¹ÏŒÎ´Î¹Î±).
+    - night=True â†’ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Î½Ï…Ï‡Ï„ÎµÏÎ¹Î½Î®/Î´Î¹Ï€Î»Î® Ï„Î±ÏÎ¯Ï†Î± Î±Î½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î· ÏƒÏ„Î¿ TAXI_TARIFF.
+    """
+    start_fee = float(TAXI_TARIFF.get("minimum_fare", 4.0))
+    day_km    = float(TAXI_TARIFF.get("km_rate_city_or_day", TAXI_TARIFF.get("km_rate_zone1", 0.9)))
+    night_km  = float(TAXI_TARIFF.get("km_rate_zone2_or_night", max(day_km, 1.25)))
+    per_km    = night_km if night else day_km
+    avg_kmh   = 85.0  # intercity Î¼Î­ÏƒÎ· Ï„Î±Ï‡ÏÏ„Î·Ï„Î±
     duration_h = distance_km / avg_kmh
     duration_min = int(round(duration_h * 60))
     cost = start_fee + per_km * distance_km
     return {
         "distance_km": round(distance_km, 1),
         "duration_min": duration_min,
         "price_eur": round(cost, 2),
     }
@@
-PLACE_SEP_PAT = r"(?:\s*[-â€“>|]\s*|\s+)"
+PLACE_SEP_PAT = r"(?:\s*[-â€“>|]\s*|,\s*|\s+)"
@@
 def _extract_route_free_text(text: str) -> Tuple[Optional[str], Optional[str]]:
@@
-    t = unicodedata.normalize("NFKC", text or "").lower()
+    t = unicodedata.normalize("NFKC", text or "").lower()
     t = re.sub(r"\s+", " ", t).strip(" ;,.;Â¿;Í¾;?")
 
     patterns = [
         r"Î±Ï€[ÏŒÎ¿]\s+(?P<origin>.+?)\s+(?:Î¼Î­Ï‡ÏÎ¹|Ï‰Ï‚|Ï€ÏÎ¿Ï‚|Î³Î¹Î±|ÏƒÎµ)\s+(?P<dest>.+)",
         r"Î±Ï€ÏŒ\s+(?P<origin>.+?)\s+(?:Î¼Î­Ï‡ÏÎ¹|Ï‰Ï‚|Ï€ÏÎ¿Ï‚|Î³Î¹Î±|ÏƒÎµ)\s+(?P<dest>.+)",
-        r"^(?P<origin>[^0-9]+?)\s+(?:Î¼Î­Ï‡ÏÎ¹|Ï€ÏÎ¿Ï‚|Î³Î¹Î±|ÏƒÎµ)\s+(?P<dest>.+)$",
-        rf"^(?P<origin>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+){PLACE_SEP_PAT}(?P<dest>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+)$",
+        r"^(?P<origin>[^0-9]+?)\s+(?:Î¼Î­Ï‡ÏÎ¹|Ï€ÏÎ¿Ï‚|Î³Î¹Î±|ÏƒÎµ|to)\s+(?P<dest>.+)$",
+        rf"^(?P<origin>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+){PLACE_SEP_PAT}(?P<dest>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+)$",
         r"Ï€ÏŒÏƒÎ¿\s+(?:ÎºÎ¬Î½ÎµÎ¹|ÎºÎ¿ÏƒÏ„Î¯Î¶ÎµÎ¹)\s+(?:Î½Î±\s+)?(?:Ï€Î¬Ï‰|Ï€Î¬Î¼Îµ|Î¼ÎµÏ„Î¬Î²Î±ÏƒÎ·)\s+(?:ÏƒÎµ|Ï€ÏÎ¿Ï‚)?\s*(?P<dest>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+)$",
         r"^(?:Î¼Î­Ï‡ÏÎ¹|Ï€ÏÎ¿Ï‚|Î³Î¹Î±)\s+(?P<dest>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+)$",
+        r"^(?:to|->)\s*(?P<dest>[a-zÎ±-Ï‰Î¬Î­Î¯ÏŒÎ®ÏÏ\. ]+)$",
     ]
@@
-    return None, None
+    return None, None
+
+def _detect_night_or_double_tariff(message: str, when: str) -> bool:
+    """
+    Î•Ï…ÏÎµÏ„Î¹ÎºÎ®: Î±Î½ Î¿ Ï‡ÏÎ®ÏƒÏ„Î·Ï‚ Î³ÏÎ¬ÏˆÎµÎ¹ 'Î½ÏÏ‡Ï„Î±', 'Î´Î¹Ï€Î»Î®', 'double', Î® Î±Î½ Ï„Î¿ when Î¼Î¿Î¹Î¬Î¶ÎµÎ¹ Î½Ï…Ï‡Ï„ÎµÏÎ¹Î½ÏŒ (00:00â€“05:00).
+    Î”ÎµÎ½ Â«Î¼Î±Î½Ï„ÎµÏÎ¿Ï…Î¼ÎµÂ» ÎµÏ€Î¹Î¸ÎµÏ„Î¹ÎºÎ¬: ÎµÎ¯Î½Î±Î¹ Î±Ï€Î»Î¬ flag Î³Î¹Î± fallback ÎºÎ¿ÏƒÏ„Î¿Î»ÏŒÎ³Î·ÏƒÎ·.
+    """
+    t = (message or "").lower()
+    if re.search(r"Î½Ï…Ï‡Ï„|Î´Î¹Ï€Î»|double", t):
+        return True
+    # when Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÎµÎ¯Î½Î±Î¹ 'now', 'tomorrow 02:30', '2025-08-10 01:15', Îº.Î»Ï€.
+    m = re.search(r"\b(\d{1,2})[:.](\d{2})\b", (when or "").lower())
+    if m:
+        hh = int(m.group(1))
+        return 0 <= hh < 5
+    return False
@@
-@function_tool
-def trip_quote_nlp(message: str, when: str = "now") -> str:
-    """
-    Î’Î³Î¬Î¶ÎµÎ¹ origin/destination Î±Ï€ÏŒ ÎµÎ»ÎµÏÎ¸ÎµÏÎ¿ ÎµÎ»Î»Î·Î½Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎºÎ±Î¹ ÎºÎ±Î»ÎµÎ¯ Ï„Î¿ TIMOLOGIO API.
-    - Î‘Î½ Î´Î¿Î¸ÎµÎ¯ Î¼ÏŒÎ½Î¿ Ï€ÏÎ¿Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚, origin = 'Î Î¬Ï„ÏÎ±'.
-    - Î Î‘ÎÎ¤Î‘ ÎµÏ€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ ÎºÎ±Î¹ Ï„Î¿ Google Maps URL *Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿* Î³Î¹Î± Î½Î± Ï†Ï„Î¹Î±Ï‡Ï„ÎµÎ¯ ÎºÎ¿Ï…Î¼Ï€Î¯ Î±Ï€ÏŒ Ï„Î¿ frontend.
-    - Î— Î´Î¹Î¬ÏÎºÎµÎ¹Î± ÎµÎ¯Î½Î±Î¹ ÏƒÎµ Î¼Î¿ÏÏ†Î® "Î§ ÏÏÎµÏ‚ ÎºÎ±Î¹ Î¥ Î»ÎµÏ€Ï„Î¬".
-    """
-    logger.info("[tool] trip_quote_nlp: parsing route from message=%r", message)
-    origin, dest = _extract_route_free_text(message)
-    if not origin or not dest:
-        return UI_TEXT.get("ask_trip_route", "â“ Î ÎµÏ‚ Î¼Î¿Ï… Î±Ï€ÏŒ Ï€Î¿Ï Î¾ÎµÎºÎ¹Î½Î¬Ï‚ ÎºÎ±Î¹ Ï€Î¿Ï Ï€Î±Ï‚ (Ï€.Ï‡. 'Î±Ï€ÏŒ Î Î¬Ï„ÏÎ± Î¼Î­Ï‡ÏÎ¹ Î›Î¿Ï…Ï„ÏÎ¬ÎºÎ¹').")
-
-def _price_band(eur: float, pct: float = 0.08) -> tuple[int, int]:
-    low = eur * (1 - pct)
-    high = eur * (1 + pct)
-    # ÏƒÏ„ÏÎ¿Î³Î³ÏÎ»ÎµÏˆÎµ ÏƒÏ„Î¿ Ï€Î»Î·ÏƒÎ¹Î­ÏƒÏ„ÎµÏÎ¿ 5â‚¬
-    def r5(x): return int(round(x / 5.0)) * 5
-    return max(0, r5(low)), r5(high)
-
-    # 1) Î ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Timologio
-    data = {"error": "unavailable"}
-    if TimologioClient is not None:
-        try:
-            client = TimologioClient()
-            data = client.estimate_trip(origin, dest, when=when)
-            logger.info("[tool] timologio response: %s", data)
-        except Exception:
-            logger.exception("[tool] timologio call failed")
-
-    # === SUCCESS PATH (Timologio OK) ===
-    if isinstance(data, dict) and "error" not in data:
-        price = (
-            data.get("price_eur")
-            or data.get("price")
-            or data.get("total_eur")
-            or data.get("fare")
-        )
-        dist = data.get("distance_km") or data.get("km") or data.get("distance")
-    
-    # ... Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ success path Ï„Î¿Ï… trip_quote_nlp:
-    if price is not None:
-        try:
-            price_val = float(str(price).replace(",", "."))
-            lo, hi = _price_band(price_val, pct=0.08)
-            parts.append(f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: {lo}â€“{hi}â‚¬")
-        except Exception:
-            parts.append(f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: ~{price}â‚¬")
-
-        # duration: Î»ÎµÏ€Ï„Î¬ / seconds / HH:MM / ISO "PT..."
-        raw_dur = (
-            data.get("duration_min")
-            or data.get("minutes")
-            or data.get("duration")
-            or data.get("duration_seconds")
-        )
-        mins = _normalize_minutes(raw_dur, distance_km=dist)
-        dur_text = _fmt_minutes(mins) if mins is not None else None
-
-        # map_url Î½Î± Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ ÏƒÏ„Î¿ ÎšÎ•Î™ÎœÎ•ÎÎŸ (Î³Î¹Î± Î½Î± Î²Î³ÎµÎ¹ Ï„Î¿ ÎºÎ¿Ï…Î¼Ï€Î¯ ÏƒÏ„Î¿ UI)
-        map_url = (
-            data.get("map_url") or data.get("mapLink") or
-            data.get("route_url") or data.get("map")
-        )
-
-        parts = []
-        if price is not None: parts.append(f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: ~{price}â‚¬")
-        if dist  is not None:
-            try:
-                parts.append(f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{round(float(dist), 2)} km")
-            except Exception:
-                parts.append(f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{dist} km")
-        if dur_text is not None: parts.append(f"â±ï¸ Î§ÏÏŒÎ½Î¿Ï‚: ~{dur_text}")
-        if map_url: parts.append(f"ğŸ“Œ Î”ÎµÏ‚ Ï„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·: {map_url}")
-        parts.append("âš ï¸ Î— Ï„Î¹Î¼Î® Î´ÎµÎ½ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î´Î¹ÏŒÎ´Î¹Î±.")
-        return "\n".join(parts)
-
-    # === FALLBACK (Timologio down) ===
-    logger.warning("[tool] timologio unavailable, using fallback")
-    dist = _rough_distance_km(origin, dest)
-    est = _estimate_price_and_time_km(dist)
-    dur_text = _fmt_minutes(est["duration_min"])
-    map_url = f"https://www.google.com/maps/dir/?api=1&origin={quote_plus(origin)}&destination={quote_plus(dest)}&travelmode=driving"
-    lo, hi = _price_band(est['price_eur'], pct=0.08)
-    return (
-        f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: {lo}â€“{hi}â‚¬\n"
-        f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{est['distance_km']} km\n"
-        f"â±ï¸ Î§ÏÏŒÎ½Î¿Ï‚: ~{dur_text}\n"
-        f"ğŸ“Œ Î”ÎµÏ‚ Ï„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·: {map_url}\n"
-        f"{UI_TEXT.get('fare_disclaimer','âš ï¸ Î— Ï„Î¹Î¼Î® Î´ÎµÎ½ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î´Î¹ÏŒÎ´Î¹Î±.')}"
-    )
+def _price_band(eur: float, pct: float = 0.08) -> tuple[int, int]:
+    low = eur * (1 - pct)
+    high = eur * (1 + pct)
+    def r5(x):  # ÏƒÏ„ÏÎ¿Î³Î³ÏÎ»ÎµÎ¼Î± ÏƒÏ„Î¿ Ï€Î»Î·ÏƒÎ¹Î­ÏƒÏ„ÎµÏÎ¿ 5â‚¬
+        return int(round(x / 5.0)) * 5
+    return max(0, r5(low)), r5(high)
+
+@function_tool
+def trip_quote_nlp(message: str, when: str = "now") -> str:
+    """
+    Î’Î³Î¬Î¶ÎµÎ¹ origin/destination Î±Ï€ÏŒ ÎµÎ»ÎµÏÎ¸ÎµÏÎ¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎºÎ±Î¹ ÎºÎ±Î»ÎµÎ¯ Timologio (Î±Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹).
+    - Î‘Î½ Î»ÎµÎ¯Ï€ÎµÎ¹ origin â†’ 'Î Î¬Ï„ÏÎ±'.
+    - Î Î‘ÎÎ¤Î‘ Î²Î¬Î¶ÎµÎ¹ Google Maps URL ÏƒÏ„Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ (frontend ÎºÎ¿Ï…Î¼Ï€Î¯).
+    - Î”Î¹Î¬ÏÎºÎµÎ¹Î± ÏƒÎµ Â«Î§ ÏÏÎµÏ‚ ÎºÎ±Î¹ Î¥ Î»ÎµÏ€Ï„Î¬Â».
+    """
+    logger.info("[tool] trip_quote_nlp: parsing route from message=%r", message)
+    origin, dest = _extract_route_free_text(message)
+    if not origin or not dest:
+        return UI_TEXT.get(
+            "ask_trip_route",
+            "â“ Î ÎµÏ‚ Î¼Î¿Ï… Î±Ï€ÏŒ Ï€Î¿Ï Î¾ÎµÎºÎ¹Î½Î¬Ï‚ ÎºÎ±Î¹ Ï€Î¿Ï Ï€Î±Ï‚ (Ï€.Ï‡. Â«Î‘Ï€ÏŒ Î Î¬Ï„ÏÎ± Î¼Î­Ï‡ÏÎ¹ Î”Î¹Î±ÎºÎ¿Ï€Ï„ÏŒÂ»).",
+        )
+
+    night = _detect_night_or_double_tariff(message, when)
+
+    # 1) Timologio
+    data: Dict[str, Any] = {"error": "unavailable"}
+    if TimologioClient is not None:
+        try:
+            client = TimologioClient()
+            data = client.estimate_trip(origin, dest, when=when)
+            logger.info("[tool] timologio response: %s", data)
+        except Exception:
+            logger.exception("[tool] timologio call failed")
+
+    # 2) SUCCESS PATH
+    if isinstance(data, dict) and "error" not in data:
+        price = (
+            data.get("price_eur")
+            or data.get("price")
+            or data.get("total_eur")
+            or data.get("fare")
+        )
+        dist = data.get("distance_km") or data.get("km") or data.get("distance")
+        raw_dur = (
+            data.get("duration_min")
+            or data.get("minutes")
+            or data.get("duration")
+            or data.get("duration_seconds")
+        )
+        mins = _normalize_minutes(raw_dur, distance_km=dist)
+        dur_text = _fmt_minutes(mins) if mins is not None else None
+        map_url = (
+            data.get("map_url")
+            or data.get("mapLink")
+            or data.get("route_url")
+            or data.get("map")
+        )
+
+        parts: List[str] = []
+        if price is not None:
+            try:
+                price_val = float(str(price).replace(",", "."))
+                lo, hi = _price_band(price_val, pct=0.08)
+                parts.append(f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: {lo}â€“{hi}â‚¬")
+            except Exception:
+                parts.append(f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: ~{price}â‚¬")
+        if dist is not None:
+            try:
+                parts.append(f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{round(float(dist), 2)} km")
+            except Exception:
+                parts.append(f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{dist} km")
+        if dur_text is not None:
+            parts.append(f"â±ï¸ Î§ÏÏŒÎ½Î¿Ï‚: ~{dur_text}")
+        if map_url:
+            parts.append(f"ğŸ“Œ Î”ÎµÏ‚ Ï„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·: {map_url}")
+        parts.append(UI_TEXT.get("fare_disclaimer", "âš ï¸ Î— Ï„Î¹Î¼Î® Î´ÎµÎ½ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î´Î¹ÏŒÎ´Î¹Î±."))
+        return "\n".join(parts)
+
+    # 3) FALLBACK (Timologio down Î® Î¼Î· Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿)
+    logger.warning("[tool] timologio unavailable, using fallback")
+    dist = _rough_distance_km(origin, dest)
+    est = _estimate_price_and_time_km(dist, night=night)
+    dur_text = _fmt_minutes(est["duration_min"])
+    map_url = (
+        f"https://www.google.com/maps/dir/?api=1"
+        f"&origin={quote_plus(origin)}&destination={quote_plus(dest)}&travelmode=driving"
+    )
+    lo, hi = _price_band(est["price_eur"], pct=0.08)
+    body = [
+        f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: {lo}â€“{hi}â‚¬" + (" (Î½ÏÏ‡Ï„Î±)" if night else ""),
+        f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{est['distance_km']} km",
+        f"â±ï¸ Î§ÏÏŒÎ½Î¿Ï‚: ~{dur_text}",
+        f"ğŸ“Œ Î”ÎµÏ‚ Ï„Î· Î´Î¹Î±Î´ÏÎ¿Î¼Î® ÏƒÏ„Î¿Î½ Ï‡Î¬ÏÏ„Î·: {map_url}",
+        UI_TEXT.get("fare_disclaimer", "âš ï¸ Î— Ï„Î¹Î¼Î® Î´ÎµÎ½ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î´Î¹ÏŒÎ´Î¹Î±."),
+    ]
+    return "\n".join(body)
@@
 @function_tool
-def trip_estimate(origin: str, destination: str) -> str:
+def trip_estimate(origin: str, destination: str, when: str = "now") -> str:
     try:
-        dist = _rough_distance_km(origin, destination)
-        est = _estimate_price_and_time_km(dist)
+        dist = _rough_distance_km(origin, destination)
+        night = _detect_night_or_double_tariff("", when)
+        est = _estimate_price_and_time_km(dist, night=night)
         return (
-            f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: ~{est['price_eur']}â‚¬\n"
+            f"ğŸ’¶ Î•ÎºÏ„Î¯Î¼Î·ÏƒÎ·: ~{est['price_eur']}â‚¬" + (" (Î½ÏÏ‡Ï„Î±)" if night else "") + "\n"
             f"ğŸ›£ï¸ Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·: ~{est['distance_km']} km\n"
             f"â±ï¸ Î§ÏÏŒÎ½Î¿Ï‚: ~{_fmt_minutes(est['duration_min'])}\n"
             f"âš ï¸ Î— Ï„Î¹Î¼Î® Î´ÎµÎ½ Ï€ÎµÏÎ¹Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Î´Î¹ÏŒÎ´Î¹Î±."
         )
     except Exception:
         logger.exception("trip_estimate failed")
         return "âŒ Î”ÎµÎ½ Î¼Ï€ÏŒÏÎµÏƒÎ± Î½Î± Ï…Ï€Î¿Î»Î¿Î³Î¯ÏƒÏ‰ Ï„Î·Î½ ÎµÎºÏ„Î¯Î¼Î·ÏƒÎ·."
